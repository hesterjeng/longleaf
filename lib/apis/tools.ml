module Headers = Cohttp.Header
module Error = Longleaf_core.Error
open Cohttp_eio

let read_body body =
  try
    Result.return
    @@ Eio.Buf_read.parse_exn Eio.Buf_read.take_all body ~max_size:max_int
  with
  | _ -> Error.fatal "problem reading body in tools.ml"

let get_cohttp ~client ~headers ~endpoint : (Yojson.Safe.t, Error.t) result =
  let ( let* ) = Result.( let* ) in
  Eio.Switch.run @@ fun sw ->
  let uri = Uri.of_string endpoint in
  let* resp, body =
    match Client.get ~headers ~sw client uri with
    | resp, body -> Ok (resp, body)
    | exception e ->
      let s = Printexc.to_string e in
      Eio.traceln "@[Error in get_cohttp: %s@]@." s;
      Result.fail @@ `Msg s
  in
  let* () =
    if Http.Status.compare resp.status `OK = 0 then Ok ()
    else
      (* Read response body to get error details *)
      let error_body =
        match read_body body with
        | Ok body_text -> body_text
        | Error _ -> "<unable to read response body>"
      in
      let headers_str = Headers.to_lines headers |> String.concat "\n  " in
      Eio.traceln
        "@[<v>GET REQUEST FAILED@,Endpoint: %s@,Status: %s@,Request Headers:@,  %s@,Response Body:@,  %s@]"
        endpoint (Http.Status.to_string resp.status) headers_str error_body;
      Error.fatal @@ Format.sprintf "tools.ml: bad response status get (status=%s)"
        (Http.Status.to_string resp.status)
  in
  let* body_string = read_body body in
  Result.return @@ Yojson.Safe.from_string body_string

let delete_cohttp ~client ~headers ~endpoint : (Yojson.Safe.t, Error.t) result =
  let ( let* ) = Result.( let* ) in
  Eio.Switch.run @@ fun sw ->
  let uri = Uri.of_string endpoint in
  let* resp, body =
    match Client.delete ~headers ~sw client uri with
    | resp, body -> Ok (resp, body)
    | exception e ->
      let s = Printexc.to_string e in
      Eio.traceln "@[Error in delete_cohttp: %s@]@." s;
      Result.fail @@ `Msg s
  in
  let* () =
    if Http.Status.compare resp.status `OK = 0 then Ok ()
    else
      (* Read response body to get error details *)
      let error_body =
        match read_body body with
        | Ok body_text -> body_text
        | Error _ -> "<unable to read response body>"
      in
      let headers_str = Headers.to_lines headers |> String.concat "\n  " in
      Eio.traceln
        "@[<v>DELETE REQUEST FAILED@,Endpoint: %s@,Status: %s@,Request Headers:@,  %s@,Response Body:@,  %s@]"
        endpoint (Http.Status.to_string resp.status) headers_str error_body;
      Error.fatal @@ Format.sprintf "tools.ml: bad response status delete (status=%s)"
        (Http.Status.to_string resp.status)
  in
  let* body_string = read_body body in
  Result.return @@ Yojson.Safe.from_string body_string

let post_cohttp ~client ~body:json_body ~headers ~endpoint :
    (Yojson.Safe.t, Error.t) result =
  let ( let* ) = Result.( let* ) in
  Eio.Switch.run @@ fun sw ->
  let body_string = Yojson.Safe.to_string json_body in
  let body = Body.of_string body_string in
  let uri = Uri.of_string endpoint in
  let* resp, body =
    match Client.post ~headers ~body ~sw client uri with
    | resp, body -> Result.return @@ (resp, body)
    | exception e ->
      invalid_arg @@ Format.asprintf "post_cohttp: %s" (Printexc.to_string e)
  in
  let* () =
    if Http.Status.compare resp.status `OK = 0 then Ok ()
    else
      (* Read response body to get error details *)
      let error_body =
        match read_body body with
        | Ok body_text -> body_text
        | Error _ -> "<unable to read response body>"
      in
      let headers_str = Headers.to_lines headers |> String.concat "\n  " in
      Eio.traceln
        "@[<v>POST REQUEST FAILED@,Endpoint: %s@,Status: %s@,Request Headers:@,  %s@,Request Body:@,  %s@,Response Body:@,  %s@]"
        endpoint (Http.Status.to_string resp.status) headers_str body_string error_body;
      Error.fatal @@ Format.sprintf "tools.ml: bad response status post (status=%s)"
        (Http.Status.to_string resp.status)
  in
  let* body_string = read_body body in
  Result.return @@ Yojson.Safe.from_string body_string

(* POST request that returns HTML instead of JSON

   This function is identical to post_cohttp except it returns the raw HTML string
   instead of attempting to parse the response body as JSON.

   Use case: The tearsheet endpoint (QuantStats FastAPI server) returns rendered HTML,
   not JSON. Calling post_cohttp would fail with a JSON parse error because the response
   starts with "<!-- generated by QuantStats..." instead of valid JSON.

   Parameters:
   - client: Cohttp_eio client
   - body: JSON body to send in the POST request
   - headers: HTTP headers
   - endpoint: URL to POST to

   Returns: Raw HTML string from the response body
*)
let post_cohttp_html ~client ~body:json_body ~headers ~endpoint :
    (string, Error.t) result =
  let ( let* ) = Result.( let* ) in
  Eio.Switch.run @@ fun sw ->
  let body_string = Yojson.Safe.to_string json_body in
  let body = Body.of_string body_string in
  let uri = Uri.of_string endpoint in
  let* resp, body =
    match Client.post ~headers ~body ~sw client uri with
    | resp, body -> Result.return @@ (resp, body)
    | exception e ->
      invalid_arg @@ Format.asprintf "post_cohttp_html: %s" (Printexc.to_string e)
  in
  let* () =
    if Http.Status.compare resp.status `OK = 0 then Ok ()
    else
      (* Read response body to get error details *)
      let error_body =
        match read_body body with
        | Ok body_text -> body_text
        | Error _ -> "<unable to read response body>"
      in
      let headers_str = Headers.to_lines headers |> String.concat "\n  " in
      Eio.traceln
        "@[<v>POST REQUEST FAILED@,Endpoint: %s@,Status: %s@,Request Headers:@,  %s@,Request Body:@,  %s@,Response Body:@,  %s@]"
        endpoint (Http.Status.to_string resp.status) headers_str body_string error_body;
      Error.fatal @@ Format.sprintf "tools.ml: bad response status post (status=%s)"
        (Http.Status.to_string resp.status)
  in
  let* body_string = read_body body in
  Result.return body_string

(* Backward compatibility aliases *)
let get_piaf = get_cohttp
let delete_piaf = delete_cohttp
let post_piaf = post_cohttp
